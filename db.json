{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/athena/source/js/script.js","path":"js/script.js","modified":1},{"_id":"themes/athena/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/athena/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/athena/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/athena/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/athena/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/athena/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/athena/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/athena/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/athena/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/athena/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/athena/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/athena/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/athena/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/athena/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/athena/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/athena/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/athena/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1},{"_id":"themes/athena/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/athena/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/athena/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/athena/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/athena/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1},{"_id":"source/robots.txt","path":"robots.txt","modified":1},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1},{"_id":"source/CNAME","path":"CNAME","modified":1}],"Cache":[{"_id":"source/404.html","shasum":"115ffee530ae7d4ee406e76776e20e9bfaeb4f9d","modified":1445848965000},{"_id":"source/CNAME","shasum":"58a245e5291e156ffab1f3b84219930adbdf45d2","modified":1445668371000},{"_id":"source/_posts/Cowboy的路由机制.md","shasum":"ffffc1ed15222492acd846f06c59be7a63f9c85c","modified":1445509518000},{"_id":"source/_posts/Erlang-Efficiency-guide-非标准笔记.md","shasum":"d1c13a6565bfc2e5a4e15aa9893606c4863ff823","modified":1445881777000},{"_id":"source/_posts/Erlang发送邮件相关问题.md","shasum":"ae42f367acd33576e535d7bccc282ec7197c740f","modified":1445509415000},{"_id":"source/_posts/Erlang通过NIF集成c代码示例.md","shasum":"6d526b75fdd71aae51c57c78ea295383f35ddba1","modified":1445520287000},{"_id":"source/_posts/MQTT-V1-3-协议详解.md","shasum":"e2d245069ac83d05d67543fffa78b6135d8e7927","modified":1445668525000},{"_id":"source/_posts/Riak安装与MapReduce测试.md","shasum":"5347e88b997c7db04e4ae0b23713d67a12003e2f","modified":1445517242000},{"_id":"source/_posts/ejabberd-receiver分析.md","shasum":"6366dad5974e562f9a5c01e80c4f3dfbfd08c04d","modified":1445515880000},{"_id":"source/_posts/hexo的archive分页问题.md","shasum":"6a4f240d33ad580001eeb4a0442a977ef39cecd2","modified":1445886927000},{"_id":"source/_posts/tsung压测restful服务器.md","shasum":"7b8c666d518cabcf14db6af0db3b6916130e548d","modified":1446798435000},{"_id":"source/favicon.ico","shasum":"2635768a4986cd46c7b92ebf94bbc7bfa7e5225f","modified":1445822983000},{"_id":"source/robots.txt","shasum":"b48691b5fc4ac919ad8fe2e0f3356cf1d1c007a3","modified":1445821330000},{"_id":"source/tags/index.md","shasum":"e2bf6350397182767e9bc51838233ce78acd208b","modified":1445509636000},{"_id":"themes/athena/Gruntfile.js","shasum":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1445860078000},{"_id":"themes/athena/README.md","shasum":"00f76fbfb76dcae2134b94396ea1049862c8cdd5","modified":1445860078000},{"_id":"themes/athena/_config.yml","shasum":"ecd02e023d15ec9e2d777c10a6579f50f35089f2","modified":1445860078000},{"_id":"themes/athena/layout/_partial/after-footer.ejs","shasum":"b7afccd52b1828c14928ece4d58383b0cf12f550","modified":1445860078000},{"_id":"themes/athena/layout/_partial/archive-post.ejs","shasum":"d45b85c4067ed8bacee55ce6b9b53c774628c66f","modified":1445860078000},{"_id":"themes/athena/layout/_partial/archive.ejs","shasum":"cb626d48e6853875ca7216df59b750824f8c7c78","modified":1445883898000},{"_id":"themes/athena/layout/_partial/article.ejs","shasum":"1254fa73d77b611fc55b4b92bd22a732d9a6f4ea","modified":1445937463000},{"_id":"themes/athena/layout/_partial/footer.ejs","shasum":"27a8573bd8f5cf3f70b7d4620dcad05dfb9e7818","modified":1447031354000},{"_id":"themes/athena/layout/_partial/google-analytics.ejs","shasum":"98a27ce8a3d3e4596787b8661efc2a59b182c13a","modified":1445860078000},{"_id":"themes/athena/layout/_partial/head.ejs","shasum":"679c8ca6bc1a02965b821ad163870d24ed5e2e2f","modified":1447151853000},{"_id":"themes/athena/layout/_partial/header.ejs","shasum":"23c4b63ab02ec4607b287d21b3bfd50e8617b9db","modified":1445860078000},{"_id":"themes/athena/layout/_partial/page.ejs","shasum":"cac8c44f734f147f035070b64e61b20d53d964b4","modified":1445860078000},{"_id":"themes/athena/layout/_partial/post/category.ejs","shasum":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1445860078000},{"_id":"themes/athena/layout/_partial/post/comment_number.ejs","shasum":"46b43d81a640bdcf57078b5b2ab96eca4233262c","modified":1445937642000},{"_id":"themes/athena/layout/_partial/post/date.ejs","shasum":"5256891d3457fe928d9e81c805bca8821fca4393","modified":1445860078000},{"_id":"themes/athena/layout/_partial/post/gallery.ejs","shasum":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1445860078000},{"_id":"themes/athena/layout/_partial/post/nav.ejs","shasum":"f26d30355ba9144c51e700e8edc6a4ab6144ff9a","modified":1445860078000},{"_id":"themes/athena/layout/_partial/post/tag.ejs","shasum":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1445860078000},{"_id":"themes/athena/layout/_partial/post/title.ejs","shasum":"f1c2029deedf8d245d8ec1d946f9ec393e3e08d0","modified":1445860078000},{"_id":"themes/athena/layout/_widget/archive.ejs","shasum":"985fbeb01142b9d526cda8ebc372c1d361d69a6b","modified":1445860078000},{"_id":"themes/athena/layout/_widget/category.ejs","shasum":"36ab37878129d152e3cbdeb839c08e52af1acd58","modified":1445860078000},{"_id":"themes/athena/layout/_widget/recent_posts.ejs","shasum":"feba7c00fa59ba13bf870b358a499fde4473d335","modified":1445860078000},{"_id":"themes/athena/layout/_widget/tag.ejs","shasum":"b3f321ddda6be2702a286d5b11af9533509506fb","modified":1445860078000},{"_id":"themes/athena/layout/_widget/tagcloud.ejs","shasum":"34dc8cdd96cdb41dd11cb7513f13714373e5104a","modified":1445860078000},{"_id":"themes/athena/layout/archive.ejs","shasum":"3393cdbd0def98d749c7a786441d1c40e3106929","modified":1445882154000},{"_id":"themes/athena/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1445860078000},{"_id":"themes/athena/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1445860078000},{"_id":"themes/athena/layout/layout.ejs","shasum":"81c85de246e1a18c2114dacf484e9c2ec0e01bc6","modified":1445860078000},{"_id":"themes/athena/layout/page.ejs","shasum":"906d4d06ddc09beb258dd72bc1d3b7b8997054dd","modified":1445860078000},{"_id":"themes/athena/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1445860078000},{"_id":"themes/athena/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1445860078000},{"_id":"themes/athena/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1445860078000},{"_id":"themes/athena/source/css/_extend.styl","shasum":"ac8f00fc2d65d7440b1aacb0643a6ec4989d3b5e","modified":1445860078000},{"_id":"themes/athena/source/css/_partial/archive.styl","shasum":"bbf774b0c4447500c53dcaf67d4198afa8406d16","modified":1445860078000},{"_id":"themes/athena/source/css/_partial/article.styl","shasum":"a1def237a714c4e9b3a75cdaa4867ba55eee5bbe","modified":1445860078000},{"_id":"themes/athena/source/css/_partial/comment.styl","shasum":"57ff147ed385771c71a2a1c1e97f980c437ce461","modified":1445860078000},{"_id":"themes/athena/source/css/_partial/footer.styl","shasum":"c96a1536944c9d2ab14ca6d55e03d64814d64f7d","modified":1445860078000},{"_id":"themes/athena/source/css/_partial/header.styl","shasum":"49dd41599525deb80737d8764f2ddf95d78a52ff","modified":1445860078000},{"_id":"themes/athena/source/css/_partial/highlight.styl","shasum":"46ed50deb267278df2b355186fe034f08a2d3bfb","modified":1445860078000},{"_id":"themes/athena/source/css/_partial/mobile.styl","shasum":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1445860078000},{"_id":"themes/athena/source/css/_util/grid.styl","shasum":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1445860078000},{"_id":"themes/athena/source/css/_util/mixin.styl","shasum":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1445860078000},{"_id":"themes/athena/source/css/_variables.styl","shasum":"89b5ac6cea322c46e2548ef4db9e48a12eb24eb5","modified":1445860078000},{"_id":"themes/athena/source/css/fonts/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1445860078000},{"_id":"themes/athena/source/css/fonts/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1445860078000},{"_id":"themes/athena/source/css/fonts/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1445860078000},{"_id":"themes/athena/source/css/style.styl","shasum":"def9a4c0d2f5c95b6e342abd56a24f822a7eda7b","modified":1445860078000},{"_id":"themes/athena/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1445860078000},{"_id":"themes/athena/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1445860078000},{"_id":"themes/athena/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1445860078000},{"_id":"themes/athena/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1445860078000},{"_id":"themes/athena/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1445860078000},{"_id":"themes/athena/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1445860078000},{"_id":"themes/athena/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1445860078000},{"_id":"themes/athena/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1445860078000},{"_id":"themes/athena/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1445860078000},{"_id":"themes/athena/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1445860078000},{"_id":"themes/athena/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1445860078000},{"_id":"themes/athena/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1445860078000},{"_id":"themes/athena/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1445860078000},{"_id":"themes/athena/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1445860078000},{"_id":"themes/athena/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1445860078000},{"_id":"themes/athena/source/js/script.js","shasum":"8fc5beeb797d3222768b0b11f7dc3318715df765","modified":1445860078000},{"_id":"themes/athena/source/css/fonts/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1445860078000},{"_id":"themes/athena/source/css/fonts/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1445860078000},{"_id":"themes/athena/source/css/images/banner.jpg","shasum":"843d9d47bf2b7b75495db11b3d765efaaae442a9","modified":1445860078000},{"_id":"public/js/script.js","modified":1447152857829,"shasum":"8fc5beeb797d3222768b0b11f7dc3318715df765"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1447152857832,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1447152857835,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1447152857837,"shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1447152857841,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1447152857843,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1447152857845,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1447152857848,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1447152857850,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1447152857854,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1447152857859,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1447152857861,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1447152857863,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1447152857867,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1447152857870,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1447152857877,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1447152858143,"shasum":"47b193856dd83cc4e4009340c9d1c2e8a80703e2"},{"_id":"public/css/images/banner.jpg","modified":1447152858258,"shasum":"843d9d47bf2b7b75495db11b3d765efaaae442a9"},{"_id":"public/css/fonts/fontawesome-webfont.woff","modified":1447152858264,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/css/fonts/fontawesome-webfont.ttf","modified":1447152858267,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/css/fonts/fontawesome-webfont.svg","modified":1447152858271,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/css/fonts/fontawesome-webfont.eot","modified":1447152858277,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/css/fonts/FontAwesome.otf","modified":1447152858282,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/robots.txt","modified":1447152858285,"shasum":"b48691b5fc4ac919ad8fe2e0f3356cf1d1c007a3"},{"_id":"public/favicon.ico","modified":1447152858290,"shasum":"2635768a4986cd46c7b92ebf94bbc7bfa7e5225f"},{"_id":"public/CNAME","modified":1447152858294,"shasum":"58a245e5291e156ffab1f3b84219930adbdf45d2"},{"_id":"public/404.html","modified":1447152858319,"shasum":"00551359323023c48016dd9bbb7d3c23b46077a4"},{"_id":"public/tags/index.html","modified":1447152858328,"shasum":"9a24bd107e9ccecf80c3b76c99f69e11b92e98bf"},{"_id":"public/2015/11/06/tsung压测restful服务器/index.html","modified":1447152858355,"shasum":"e49dcb0fa56537cd63b023d19a13eb4a604391a0"},{"_id":"public/2015/10/27/hexo的archive分页问题/index.html","modified":1447152858362,"shasum":"d636d7f36bd664902f693d95da07376d4c676390"},{"_id":"public/2015/10/24/MQTT-V1-3-协议详解/index.html","modified":1447152858371,"shasum":"a31f4c04395940c07d576ed6a3f603f2ba7fcf5e"},{"_id":"public/2015/10/24/Erlang-Efficiency-guide-非标准笔记/index.html","modified":1447152858382,"shasum":"cfca23e377f6ef1f675ff3344bfe9c7d578f9bda"},{"_id":"public/2015/10/22/Erlang通过NIF集成c代码示例/index.html","modified":1447152858390,"shasum":"3ba11f374957ce3269bb9e03a04f681d9903a538"},{"_id":"public/2015/10/22/Riak安装与MapReduce测试/index.html","modified":1447152858415,"shasum":"b98aed12247d4c4132b778c6ca72cb238df956ce"},{"_id":"public/2015/10/22/ejabberd-receiver分析/index.html","modified":1447152858429,"shasum":"5e0b3e6ab79a1ec285c64bccce8f1072f03f4fec"},{"_id":"public/2015/10/22/Cowboy的路由机制/index.html","modified":1447152858443,"shasum":"3f4823afb548acca869135748fdbca4b1f6fedcc"},{"_id":"public/2015/10/22/Erlang发送邮件相关问题/index.html","modified":1447152858454,"shasum":"064fb788052badd34dce68b800c2273f59a6ca73"},{"_id":"public/archives/index.html","modified":1447152858489,"shasum":"a5387881523fa0cded896cf5999179c0a9972324"},{"_id":"public/archives/2015/index.html","modified":1447152858517,"shasum":"fdb16d90683f33b6dc78b7de8757958b9d78e925"},{"_id":"public/archives/2015/10/index.html","modified":1447152858554,"shasum":"301410083c2b8c40f81d4eb77bd3c16f888eca93"},{"_id":"public/archives/2015/11/index.html","modified":1447152858562,"shasum":"09829eebeded3f49f717b9faaf82200024b345df"},{"_id":"public/index.html","modified":1447152858592,"shasum":"e121f275e7cd22b961c020151e630e5c920b433e"},{"_id":"public/page/2/index.html","modified":1447152858608,"shasum":"78d8a798d4fd461511abad6c3c085b8338da4476"},{"_id":"public/tags/Erlang/index.html","modified":1447152858625,"shasum":"ef587bcd3135b96bbb9839184ba9c369418c51be"},{"_id":"public/tags/Tsung/index.html","modified":1447152858644,"shasum":"573c3631f84a0374fbb8c9b83c4c8025370c3b81"},{"_id":"public/tags/压测/index.html","modified":1447152858651,"shasum":"deed1598c4bac5425907287137991fa2f6b37149"},{"_id":"public/tags/hexo/index.html","modified":1447152858660,"shasum":"a98721d2bfa093292c60daf3e3d01cab6660fc69"},{"_id":"public/tags/Ejabberd/index.html","modified":1447152858668,"shasum":"c9291c3bfeeb97f6128b8f6d92533f85f62505fc"},{"_id":"public/tags/Riak/index.html","modified":1447152858680,"shasum":"efd2366d622af1add8ec655477f1989384685516"},{"_id":"public/tags/MapReduce/index.html","modified":1447152858688,"shasum":"0cc343cdf1b3ca924dc6e093b6653a4de31d3d35"},{"_id":"public/tags/mqtt/index.html","modified":1447152858698,"shasum":"553ce78fbf88310938ac32a86850213bb8930901"},{"_id":"public/tags/Cowboy/index.html","modified":1447152858707,"shasum":"61e71874f4d00a7403a8f484b7c03586cd635f56"},{"_id":"public/sitemap.xml","modified":1447152858711,"shasum":"701d9868a0c38dbd73bfc08e65fbe76e04825ba5"}],"Category":[],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"http://blog.csbzy.com\" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>\n","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"http://blog.csbzy.com\" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>\n","date":"2015-10-26T08:42:45.000Z","updated":"2015-10-26T08:42:45.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cigt9g31e0000yns66n8lb85s"},{"title":"tags","date":"2015-10-22T10:26:39.000Z","type":"tags","comment":false,"_content":"","source":"tags/index.md","raw":"title: tags\ndate: 2015-10-22 18:26:39\ntype: \"tags\"\ncomment: false\n---\n","updated":"2015-10-22T10:27:16.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cigt9g31x0001yns67v1zzimr"}],"Post":[{"title":"tsung压测restful服务器","date":"2015-11-06T08:18:20.000Z","_content":"\n1. android 手机一部\n2. tsung 环境\n\n思路：使用tsung的recorder功能 先记录下app的请求内容(这个可以通过 让手机代理到tsung机器的指定端口），然后让tsung使用recorder记录下来的xml文件无脑进行回放，以达到测试服务性压力。\n\n\n\n\n1.tsung启动监听代理\n======\n执行`tsung-recorder -p http -L 8080 start`,这样就会直接进行代理，并记录通过8080端口的协议内容，然后就可以在app上面点击功能让app向服务器请求内容。\n\n\n2.编辑tsung.xml配置\n======\n第一步生成的recorder 的xml文件默认在`~/.tsung/tsung_recorder_date.xml`,内容格式大概如下：\n\n     \n```xml\n<session name='rec20151106-1447' probability='100'  type='ts_http' bidi=\"true\">\n<request><http url='http://172.16.2.106:80/api/v1/bookclubserver/mp/get' version='1.1'  contents='{\"user_id\":\"144447713885360800\",\"page_size\":\"10\",\"filter_goods_id_set\":[],\"filter_user_type_set\":[],\"p_version\":\"1\",\"page_index\":\"0\"}' content_type='application/json' method='POST'><add_cookie key=\"ifm_sid\" value=\"0521be8ac72fcf353dc38db77049ce2f\"/></http></request>\n\n<thinktime random='true' value='1'/>\n\n<request><http url='http://172.16.2.103/data/app_user/upload/144447713885360800/logo_144447713885360800_logo.png' version='1.1' method='GET'><add_cookie key=\"ifm_sid\" value=\"0521be8ac72fcf353dc38db77049ce2f\"/></http></request>\n<request><http url='/data/app_user/upload/144447713885360800/logo_144447713885360800_logo.png' version='1.1' method='GET'><add_cookie key=\"ifm_sid\" value=\"0521be8ac72fcf353dc38db77049ce2f\"/></http></request>\n\n<thinktime random='true' value='3'/>\n\n<request><http url='http://172.16.2.106:80/api/personalserver/personalinfo/get' version='1.1'  contents='{\"user_id\":\"144447713885360800\",\"p_version\":\"1\"}' content_type='application/json' method='POST'><add_cookie key=\"ifm_sid\" value=\"0521be8ac72fcf353dc38db77049ce2f\"/></http></request>\n<request><http url='http://172.16.2.103/data/app_user/upload/144447713885360800/logo_144447713885360800_logo.png' version='1.1' method='GET'><add_cookie key=\"ifm_sid\" value=\"0521be8ac72fcf353dc38db77049ce2f\"/></http></request>\n<request><http url='http://172.16.2.106:80/api/bookclubserver/bookreader/fprint/get' version='1.1'  contents='{\"user_id\":\"144447713885360800\",\"p_version\":\"1\",\"page_size\":\"120\",\"page_index\":\"0\"}' content_type='application/json' method='POST'><add_cookie key=\"ifm_sid\" value=\"0521be8ac72fcf353dc38db77049ce2f\"/></http></request>\n\n<thinktime random='true' value='2'/>\n....\n</session>\n```\n   编辑好的tsung.xml如下，可以按照[tsung文档](http://tsung.erlang-projects.org/user_manual/configuration.html)的来配置，其实觉得挺复杂的。。：\n```xml\n <?xml version=\"1.0\"?>\n<!DOCTYPE tsung SYSTEM \"/usr/local/share/tsung/tsung-1.0.dtd\"[ <!ENTITY mysession1 SYSTEM \"/root/.tsung/tsung_recorder20151106-1447.xml\">\n]>\n<tsung loglevel=\"notice\" version=\"1.0\">\n  <!-- Client side setup -->\n  <clients>\n    <client host=\"localhost\" use_controller_vm=\"true\" maxusers=\"30000\"/>\n  </clients>\n \n  <!-- Server side setup -->\n<servers>\n <server host=\"localhost\" port=\"8080\"  type=\"tcp\"></server>\n</servers>\n  <!-- to start os monitoring (cpu, network, memory). Use an erlang\n  agent on the remote machine or SNMP. erlang is the default -->\n  <monitoring>\n    <monitor host=\"myserver\" type=\"snmp\"></monitor>\n  </monitoring>\n \n  <load>\n  <!-- several arrival phases can be set: for each phase, you can set\n  the mean inter-arrival time between new clients and the phase\n  duration -->\n   <arrivalphase phase=\"1\" duration=\"10\" unit=\"minute\">\n     <users interarrival=\"2\" unit=\"second\"></users>\n   </arrivalphase>\n  </load>\n  <options>\n   <option type=\"ts_http\" name=\"user_agent\">\n    <user_agent probability=\"80\">Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.7.8) Gecko/20050513 Galeon/1.3.21</user_agent>\n    <user_agent probability=\"20\">Mozilla/5.0 (Windows; U; Windows NT 5.2; fr-FR; rv:1.7.8) Gecko/20050511 Firefox/1.0.4</user_agent>\n   </option>\n  </options>\n  <!-- start a session for a http user. the probability is the\n  frequency of this type os session. The sum of all session's\n  probabilities must be 100 -->\n <sessions>\n &mysession1;\n </sessions>\n</tsung>\n\n```\n\n\n3.进行压测\n======\n执行`tsung start`就可以开始进行压测了\n\n4.生成report\n======\n最后cd到`~/.tsung/log/data/`里面执行执行 `tsung_stats.pl`   生成` report.html`\n","source":"_posts/tsung压测restful服务器.md","raw":"title: tsung压测restful服务器\ndate: 2015-11-06 16:18:20\ntags: [Erlang,Tsung,压测]\n---\n\n1. android 手机一部\n2. tsung 环境\n\n思路：使用tsung的recorder功能 先记录下app的请求内容(这个可以通过 让手机代理到tsung机器的指定端口），然后让tsung使用recorder记录下来的xml文件无脑进行回放，以达到测试服务性压力。\n\n\n\n\n1.tsung启动监听代理\n======\n执行`tsung-recorder -p http -L 8080 start`,这样就会直接进行代理，并记录通过8080端口的协议内容，然后就可以在app上面点击功能让app向服务器请求内容。\n\n\n2.编辑tsung.xml配置\n======\n第一步生成的recorder 的xml文件默认在`~/.tsung/tsung_recorder_date.xml`,内容格式大概如下：\n\n     \n```xml\n<session name='rec20151106-1447' probability='100'  type='ts_http' bidi=\"true\">\n<request><http url='http://172.16.2.106:80/api/v1/bookclubserver/mp/get' version='1.1'  contents='{\"user_id\":\"144447713885360800\",\"page_size\":\"10\",\"filter_goods_id_set\":[],\"filter_user_type_set\":[],\"p_version\":\"1\",\"page_index\":\"0\"}' content_type='application/json' method='POST'><add_cookie key=\"ifm_sid\" value=\"0521be8ac72fcf353dc38db77049ce2f\"/></http></request>\n\n<thinktime random='true' value='1'/>\n\n<request><http url='http://172.16.2.103/data/app_user/upload/144447713885360800/logo_144447713885360800_logo.png' version='1.1' method='GET'><add_cookie key=\"ifm_sid\" value=\"0521be8ac72fcf353dc38db77049ce2f\"/></http></request>\n<request><http url='/data/app_user/upload/144447713885360800/logo_144447713885360800_logo.png' version='1.1' method='GET'><add_cookie key=\"ifm_sid\" value=\"0521be8ac72fcf353dc38db77049ce2f\"/></http></request>\n\n<thinktime random='true' value='3'/>\n\n<request><http url='http://172.16.2.106:80/api/personalserver/personalinfo/get' version='1.1'  contents='{\"user_id\":\"144447713885360800\",\"p_version\":\"1\"}' content_type='application/json' method='POST'><add_cookie key=\"ifm_sid\" value=\"0521be8ac72fcf353dc38db77049ce2f\"/></http></request>\n<request><http url='http://172.16.2.103/data/app_user/upload/144447713885360800/logo_144447713885360800_logo.png' version='1.1' method='GET'><add_cookie key=\"ifm_sid\" value=\"0521be8ac72fcf353dc38db77049ce2f\"/></http></request>\n<request><http url='http://172.16.2.106:80/api/bookclubserver/bookreader/fprint/get' version='1.1'  contents='{\"user_id\":\"144447713885360800\",\"p_version\":\"1\",\"page_size\":\"120\",\"page_index\":\"0\"}' content_type='application/json' method='POST'><add_cookie key=\"ifm_sid\" value=\"0521be8ac72fcf353dc38db77049ce2f\"/></http></request>\n\n<thinktime random='true' value='2'/>\n....\n</session>\n```\n   编辑好的tsung.xml如下，可以按照[tsung文档](http://tsung.erlang-projects.org/user_manual/configuration.html)的来配置，其实觉得挺复杂的。。：\n```xml\n <?xml version=\"1.0\"?>\n<!DOCTYPE tsung SYSTEM \"/usr/local/share/tsung/tsung-1.0.dtd\"[ <!ENTITY mysession1 SYSTEM \"/root/.tsung/tsung_recorder20151106-1447.xml\">\n]>\n<tsung loglevel=\"notice\" version=\"1.0\">\n  <!-- Client side setup -->\n  <clients>\n    <client host=\"localhost\" use_controller_vm=\"true\" maxusers=\"30000\"/>\n  </clients>\n \n  <!-- Server side setup -->\n<servers>\n <server host=\"localhost\" port=\"8080\"  type=\"tcp\"></server>\n</servers>\n  <!-- to start os monitoring (cpu, network, memory). Use an erlang\n  agent on the remote machine or SNMP. erlang is the default -->\n  <monitoring>\n    <monitor host=\"myserver\" type=\"snmp\"></monitor>\n  </monitoring>\n \n  <load>\n  <!-- several arrival phases can be set: for each phase, you can set\n  the mean inter-arrival time between new clients and the phase\n  duration -->\n   <arrivalphase phase=\"1\" duration=\"10\" unit=\"minute\">\n     <users interarrival=\"2\" unit=\"second\"></users>\n   </arrivalphase>\n  </load>\n  <options>\n   <option type=\"ts_http\" name=\"user_agent\">\n    <user_agent probability=\"80\">Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.7.8) Gecko/20050513 Galeon/1.3.21</user_agent>\n    <user_agent probability=\"20\">Mozilla/5.0 (Windows; U; Windows NT 5.2; fr-FR; rv:1.7.8) Gecko/20050511 Firefox/1.0.4</user_agent>\n   </option>\n  </options>\n  <!-- start a session for a http user. the probability is the\n  frequency of this type os session. The sum of all session's\n  probabilities must be 100 -->\n <sessions>\n &mysession1;\n </sessions>\n</tsung>\n\n```\n\n\n3.进行压测\n======\n执行`tsung start`就可以开始进行压测了\n\n4.生成report\n======\n最后cd到`~/.tsung/log/data/`里面执行执行 `tsung_stats.pl`   生成` report.html`\n","slug":"tsung压测restful服务器","published":1,"updated":"2015-11-06T08:27:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigt9g3200002yns6o0iou6v5"},{"title":"hexo的archive分页问题","date":"2015-10-26T18:37:11.000Z","_content":"在配置hexo的过程中，希望的效果是首页的文章分页，然后 archives和tags的文章不分页。\n开始以为是主题的代码实现bug，蒙头去改。后来才发现是配置问题，在hexo的[issue](https://github.com/hexojs/hexo/issues/1553)里面也有这样的记录.\n本人的hexo版本是 3.0 ，步骤如下：\n1.安装 hexo-generator-archive： `npm hexo-generator-archive --save`\n2.配置`_config.yml`，修改：\n\n```shell\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 6\npagination_dir: page\narchive_generator:\n  yearly: true\n  monthly: true\n  per_page: 0\ncategory_generator:\n  per_page: 0\ntag_generator:\n  per_page: 0\n```\n\n\n","source":"_posts/hexo的archive分页问题.md","raw":"title: hexo的archive分页问题\ndate: 2015-10-27 02:37:11\ntags: [hexo]\n---\n在配置hexo的过程中，希望的效果是首页的文章分页，然后 archives和tags的文章不分页。\n开始以为是主题的代码实现bug，蒙头去改。后来才发现是配置问题，在hexo的[issue](https://github.com/hexojs/hexo/issues/1553)里面也有这样的记录.\n本人的hexo版本是 3.0 ，步骤如下：\n1.安装 hexo-generator-archive： `npm hexo-generator-archive --save`\n2.配置`_config.yml`，修改：\n\n```shell\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 6\npagination_dir: page\narchive_generator:\n  yearly: true\n  monthly: true\n  per_page: 0\ncategory_generator:\n  per_page: 0\ntag_generator:\n  per_page: 0\n```\n\n\n","slug":"hexo的archive分页问题","published":1,"updated":"2015-10-26T19:15:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigt9g3250009yns6zh3n9zt0"},{"title":"ejabberd_receiver分析","date":"2015-10-22T12:10:51.000Z","_content":"\nejabberd_receiver 分析\n=====\n`ejabberd_receiver`是ejabberd 中 网关层的数据receive模块，客户端发送的数据通过`ejabberd_receiver` 接收并通过xml port解析后发送给 ejabberd_c2s的实例处理，至于它的加密、压缩、解压之类的就不说了。\n\n主要说一下这个shaper（字母翻译：脉冲整形器，个人理解，流量控制）机制,什么意思呢？\n\n原来 `ejabberd_receiver`会根据本次socket接收到的包的大小，判断是否需要缓冲一会再接收下一个socket包，这里用到了socket参数`{active, once}`\n\n算法如下：\n    根据本次收到的包的大小 和 maxrate 算出应该缓冲多少s，再算出上一次 到 本次接收数据包的时间间隔来决定是否需要缓冲。\n\nshaper:update/2:\n\n```erlang\nupdate(none, _Size) -> {none, 0};\nupdate(#maxrate{} = State, Size) ->\n    MinInterv = 1000 * Size /(2 * State#maxrate.maxrate - State#maxrate.lastrate),\n    Interv = (now_to_usec(now()) - State#maxrate.lasttime) /1000, \n    ?DEBUG(\"State: ~p, Size=~p~nM=~p, I=~p~n\",\n    [State, Size, MinInterv, Interv]),\n    Pause = if \n                MinInterv > Interv ->\n                    1 + trunc(MinInterv - Interv);\n                true -> 0\n            end,\n    NextNow = now_to_usec(now()) + Pause * 1000,\n    {State#maxrate{lastrate =(State#maxrate.lastrate + 1000000 * Size / (NextNow - State#maxrate.lasttime)) / 2, lasttime = NextNow},\n    Pause}.\n```\n\nejabberd_receive:process_date/2\n\n```erlang\nprocess_data(Data,#state{xml_stream_state = XMLStreamState,shaper_state = ShaperState, c2s_pid = C2SPid} =State) ->\n    ?DEBUG(\"Received XML on stream = ~p\", [(Data)]),\n    XMLStreamState1 = xml_stream:parse(XMLStreamState, Data),\n    lager:info(\"XMLStreamState1 ~p\",[XMLStreamState1]),\n    {NewShaperState, Pause} = shaper:update(ShaperState, byte_size(Data)),\n    lager:info(\"pause :~p \\n pid :~p\",[Pause,C2SPid]),\n    if\n        C2SPid == undefined ->\n            ok;\n        Pause > 0 ->\n            erlang:start_timer(Pause, self(), activate);\n        true ->\n            activate_socket(State)\n    end,\n    State#state{xml_stream_state = XMLStreamState1,shaper_state = NewShaperState}.\n```\n","source":"_posts/ejabberd-receiver分析.md","raw":"title: ejabberd_receiver分析\ndate: 2015-10-22 20:10:51\ntags: [Ejabberd]\n---\n\nejabberd_receiver 分析\n=====\n`ejabberd_receiver`是ejabberd 中 网关层的数据receive模块，客户端发送的数据通过`ejabberd_receiver` 接收并通过xml port解析后发送给 ejabberd_c2s的实例处理，至于它的加密、压缩、解压之类的就不说了。\n\n主要说一下这个shaper（字母翻译：脉冲整形器，个人理解，流量控制）机制,什么意思呢？\n\n原来 `ejabberd_receiver`会根据本次socket接收到的包的大小，判断是否需要缓冲一会再接收下一个socket包，这里用到了socket参数`{active, once}`\n\n算法如下：\n    根据本次收到的包的大小 和 maxrate 算出应该缓冲多少s，再算出上一次 到 本次接收数据包的时间间隔来决定是否需要缓冲。\n\nshaper:update/2:\n\n```erlang\nupdate(none, _Size) -> {none, 0};\nupdate(#maxrate{} = State, Size) ->\n    MinInterv = 1000 * Size /(2 * State#maxrate.maxrate - State#maxrate.lastrate),\n    Interv = (now_to_usec(now()) - State#maxrate.lasttime) /1000, \n    ?DEBUG(\"State: ~p, Size=~p~nM=~p, I=~p~n\",\n    [State, Size, MinInterv, Interv]),\n    Pause = if \n                MinInterv > Interv ->\n                    1 + trunc(MinInterv - Interv);\n                true -> 0\n            end,\n    NextNow = now_to_usec(now()) + Pause * 1000,\n    {State#maxrate{lastrate =(State#maxrate.lastrate + 1000000 * Size / (NextNow - State#maxrate.lasttime)) / 2, lasttime = NextNow},\n    Pause}.\n```\n\nejabberd_receive:process_date/2\n\n```erlang\nprocess_data(Data,#state{xml_stream_state = XMLStreamState,shaper_state = ShaperState, c2s_pid = C2SPid} =State) ->\n    ?DEBUG(\"Received XML on stream = ~p\", [(Data)]),\n    XMLStreamState1 = xml_stream:parse(XMLStreamState, Data),\n    lager:info(\"XMLStreamState1 ~p\",[XMLStreamState1]),\n    {NewShaperState, Pause} = shaper:update(ShaperState, byte_size(Data)),\n    lager:info(\"pause :~p \\n pid :~p\",[Pause,C2SPid]),\n    if\n        C2SPid == undefined ->\n            ok;\n        Pause > 0 ->\n            erlang:start_timer(Pause, self(), activate);\n        true ->\n            activate_socket(State)\n    end,\n    State#state{xml_stream_state = XMLStreamState1,shaper_state = NewShaperState}.\n```\n","slug":"ejabberd-receiver分析","published":1,"updated":"2015-10-22T12:11:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigt9g327000cyns6ivxpa7yj"},{"title":"Riak安装与MapReduce测试","date":"2015-10-22T12:33:37.000Z","_content":"Riak安装与MapReduce测试\n===\n1.安装环境:\n=====\n1. Ubuntu 14.04\n2. riak-2.1.1 源码编译\n3. erlang版本R16B03-1(注意 riak目前还不支持R17以上的erlang 版本)\n\n2.依赖安装\n=====\n1. ssl :sudo apt-get install libssl0.9.8\n2. pam library: sudo apt-get install libpam0g-dev\n\n3.下载并编译riak\n=====\n1. 下载:`wget http://s3.amazonaws.com/downloads.basho.com/riak/2.1/2.1.1/riak-2.1.1.tar.gz`\n2. 解压:`tar zxvf riak-2.1.1.tar.gz`\n3. 编译:`cd riak-2.1.1 && make`\n\n4.构建riak集群\n=====\n1. 生成riak node实例:`make devrel DEVNODES=$N`,其中N是想要生成的节点数\n2. 配置riak node ：riak的配置文件位于 $RIAK_HOME/dev/dev*/etc/riak.conf,可以配置节点名称,HTTP服务监听IP和端口,PCB 协议监听IP和端口storage backend(存储后端) 等。\n3. 启动riak node :`$RIAK_NODE_ROOT/bin/riak start`\n4. 组成集群\n\n  1. 加入集群： `$RIAK_NODE_ROOT/bin/riak-admin cluster join $NODENAME`\n  2. `$RIAK_NODE_ROOT/bin/riak-admin cluster plan`\n  3. 提交:`$RIAK_NODE_ROOT/bin/riak-admin cluster commit`\n  4. 查看集群状态:`$RIAK_NODE_ROOT/bin/riak-admin member-status`\n\n5.相关官方文档\n=====\n1. riak.conf 配置文件：`http://docs.basho.com/riak/2.1.1/ops/building/configuration/`\n2. riak和riak-admin:`http://docs.basho.com/riak/2.1.1/ops/running/tools/riak/` 、`http://docs.basho.com/riak/2.1.1/ops/running/tools/riak-admin/`\n3. 存储后端的选择：`http://docs.basho.com/riak/latest/ops/building/planning/backends/`\n4. MapReduce:`http://docs.basho.com/riak/2.1.1/dev/advanced/mapreduce/`\n\n6.MapReduce 实践\n=====\nMapReduce是Riak主要用于非主键查询的方法，但是MapReduce 操作的代价是十分昂贵的，甚至会降低生产环境集群的性能。因此，应当尽量少用MapReduce，并且永远不要用于实时查询。Riak允许你通过Erlang或者Javascript来进行MapReduce操作，但是从Riak2.0开始，javascript开始被弃用。\nMapReduce测试：\n五台机器，组成集群：\n一台 \nmodel name      : Intel(R) Core(TM) i5-4460  CPU @ 3.20GHz\nMemTotal:        1429236 kB\n四台\nIntel(R) Xeon(R) CPU E5-2620 0 @ 2.00GHz\nMemTotal:       65897328 kB\n\n\n在erlang shell里面输入：\n```erlang\n    {A,B,C}=erlang:now(),\n    {ok, Soc1} = riakc_pb_socket:start_link(\"127.0.0.1\", 10017),\n    Map =fun(V, _, _) ->\n        {struct, PropList} = mochijson2:decode(riak_object:get_value(V)),\n        U = proplists:get_value(<<\"user_id\">>, PropList),\n        [dict:from_list([{U, 1}])]\n    end,\n    Reduce = fun(Results, _) ->\n        Return =\n        lists:foldl(fun(D, Acc) ->\n        dict:merge(fun(_, X, Y) -> X + Y end, D, Acc)\n        end, dict:new(), lists:flatten([Results])),\n        [Return]\n    end,\n    Reslut = riakc_pb_socket:mapred_bucket(Soc1, <<\"user_read_log4\">>, [{map, {qfun, Map}, none, false}, {reduce, {qfun, \t\tReduce}, none, true}], 6000000),\n    {A1,B1,C1}=erlang:now(),\n    (A1* 1000000000000 + B1*1000000 + C1)  - (A* 1000000000000 + B*1000000+ C).\n```\n\n%通过PCB接口，使用erlang进行MapReduce处理 240080 条数据，耗时 62112283 微秒，约等于 62s\n\n```shell\n  root@localhost:/data/riak-2.1.1# date +%s\n\t1442537754\n\troot@localhost:/data/riak-2.1.1# curl -XPOST -H\"content-type: application/json\"\\\n        http://localhost:10018/mapred --data @-<<\\EOF\n    \t{\"inputs\":\"user_read_log4\",\"query\":[{\"map\":{\"language\":\"javascript\",\"source\":\"\n    \tfunction(v) {\n    \tvar data=Riak.mapValuesJson(v)[0];\n    \tvar r={};\n    \tr[data.user_id]=1;\n   \treturn [r];\n    \t}\",\"keep\":false}},\n    \t{\"reduce\":{\"language\":\"javascript\",\"source\":\"\n    \tfunction(v){\n                    var i, j, r = {}, w;\n                for (i = 0; i < v.length; i += 1) {\n                    for (w in v[i]) {\n                        if (v[i].hasOwnProperty(w)) {\n                            if (r[w]) { r[w] += v[i][w]; }\n                            else { r[w] = v[i][w]; }\n                        }\n                    }\n                }\n                return [r];\n    \t}\"\n    \t}}],\"timeout\":1000000}\n \tEOF\n\troot@localhost:/data/riak-2.1.1# date +%s\n\t1442538003\n```\n\n\n%通过http接口，使用javascript 进行Mapreduce 处理240080 条数据，1442538003-1442537754=249s\n\n```erlang\n\tmap_javascript()->\n    \t{A,B,C}=erlang:now(),\n    \t{ok, Soc1} = riakc_pb_socket:start_link(\"127.0.0.1\", 10017),\n    \tMap= <<\"function(v) { var data=Riak.mapValuesJson(v)[0];var r={};r[data.user_id]=1;return [r];}\">>,\n    \tReduce= <<\"function(v){var i, j, r = {}, w;for (i = 0; i < v.length; i += 1) {for (w in v[i]) \\\n           {if (v[i].hasOwnProperty(w)) {if (r[w]) { r[w] += v[i][w]; }else { r[w] = v[i][w]; }}}}return [r];}\" >>,\n    \tResult=riakc_pb_socket:mapred_bucket(Soc1, <<\"user_read_log4\">>, [{map, {jsanon, Map}, none, false}, {reduce, {jsanon, Reduce}, none, true}], 6000000),\n    \t{A1,B1,C1}=erlang:now(),\n    \t{Result,(A1* 1000000000000 + B1*1000000 + C1)  - (A* 1000000000000 + B*1000000+ C)}.\n\n\t(book_club_server@localhost)11> bus_user_read_behaviortrace_handler:map_javascript().\n\t{{ok,[{1,\n       \t[{struct,[{<<\"201507301601028734\">>,27301},\n                 {<<\"201507301601028728\">>,26948},\n                 {<<\"201507301601028735\">>,23250},\n                 {<<\"201507301601028733\">>,27156},\n                 {<<\"201507301601028730\">>,27175},\n                 {<<\"201507301601028732\">>,26993},\n                 {<<\"201507301601028727\">>,26930},\n                 {<<\"201507301601028729\">>,27177},\n                 {<<\"201507301601028731\">>,27150}]}]}]},240914091}\n```\n%通过PCB协议接口，使用Javascript 进行MapReduce处理240080 条数据，耗时 240914091微妙 ，约240秒.\n```\n\n\n通过上面的测试，我们就可以知道为什么Riak自己都不推荐使用Javascript 进行MapReduce了，使用Erlang  的进行MapReduce的效率几乎是 javascript 的4倍。\n\n\n\n","source":"_posts/Riak安装与MapReduce测试.md","raw":"title: Riak安装与MapReduce测试\ndate: 2015-10-22 20:33:37\ntags: [Riak,MapReduce]\n---\nRiak安装与MapReduce测试\n===\n1.安装环境:\n=====\n1. Ubuntu 14.04\n2. riak-2.1.1 源码编译\n3. erlang版本R16B03-1(注意 riak目前还不支持R17以上的erlang 版本)\n\n2.依赖安装\n=====\n1. ssl :sudo apt-get install libssl0.9.8\n2. pam library: sudo apt-get install libpam0g-dev\n\n3.下载并编译riak\n=====\n1. 下载:`wget http://s3.amazonaws.com/downloads.basho.com/riak/2.1/2.1.1/riak-2.1.1.tar.gz`\n2. 解压:`tar zxvf riak-2.1.1.tar.gz`\n3. 编译:`cd riak-2.1.1 && make`\n\n4.构建riak集群\n=====\n1. 生成riak node实例:`make devrel DEVNODES=$N`,其中N是想要生成的节点数\n2. 配置riak node ：riak的配置文件位于 $RIAK_HOME/dev/dev*/etc/riak.conf,可以配置节点名称,HTTP服务监听IP和端口,PCB 协议监听IP和端口storage backend(存储后端) 等。\n3. 启动riak node :`$RIAK_NODE_ROOT/bin/riak start`\n4. 组成集群\n\n  1. 加入集群： `$RIAK_NODE_ROOT/bin/riak-admin cluster join $NODENAME`\n  2. `$RIAK_NODE_ROOT/bin/riak-admin cluster plan`\n  3. 提交:`$RIAK_NODE_ROOT/bin/riak-admin cluster commit`\n  4. 查看集群状态:`$RIAK_NODE_ROOT/bin/riak-admin member-status`\n\n5.相关官方文档\n=====\n1. riak.conf 配置文件：`http://docs.basho.com/riak/2.1.1/ops/building/configuration/`\n2. riak和riak-admin:`http://docs.basho.com/riak/2.1.1/ops/running/tools/riak/` 、`http://docs.basho.com/riak/2.1.1/ops/running/tools/riak-admin/`\n3. 存储后端的选择：`http://docs.basho.com/riak/latest/ops/building/planning/backends/`\n4. MapReduce:`http://docs.basho.com/riak/2.1.1/dev/advanced/mapreduce/`\n\n6.MapReduce 实践\n=====\nMapReduce是Riak主要用于非主键查询的方法，但是MapReduce 操作的代价是十分昂贵的，甚至会降低生产环境集群的性能。因此，应当尽量少用MapReduce，并且永远不要用于实时查询。Riak允许你通过Erlang或者Javascript来进行MapReduce操作，但是从Riak2.0开始，javascript开始被弃用。\nMapReduce测试：\n五台机器，组成集群：\n一台 \nmodel name      : Intel(R) Core(TM) i5-4460  CPU @ 3.20GHz\nMemTotal:        1429236 kB\n四台\nIntel(R) Xeon(R) CPU E5-2620 0 @ 2.00GHz\nMemTotal:       65897328 kB\n\n\n在erlang shell里面输入：\n```erlang\n    {A,B,C}=erlang:now(),\n    {ok, Soc1} = riakc_pb_socket:start_link(\"127.0.0.1\", 10017),\n    Map =fun(V, _, _) ->\n        {struct, PropList} = mochijson2:decode(riak_object:get_value(V)),\n        U = proplists:get_value(<<\"user_id\">>, PropList),\n        [dict:from_list([{U, 1}])]\n    end,\n    Reduce = fun(Results, _) ->\n        Return =\n        lists:foldl(fun(D, Acc) ->\n        dict:merge(fun(_, X, Y) -> X + Y end, D, Acc)\n        end, dict:new(), lists:flatten([Results])),\n        [Return]\n    end,\n    Reslut = riakc_pb_socket:mapred_bucket(Soc1, <<\"user_read_log4\">>, [{map, {qfun, Map}, none, false}, {reduce, {qfun, \t\tReduce}, none, true}], 6000000),\n    {A1,B1,C1}=erlang:now(),\n    (A1* 1000000000000 + B1*1000000 + C1)  - (A* 1000000000000 + B*1000000+ C).\n```\n\n%通过PCB接口，使用erlang进行MapReduce处理 240080 条数据，耗时 62112283 微秒，约等于 62s\n\n```shell\n  root@localhost:/data/riak-2.1.1# date +%s\n\t1442537754\n\troot@localhost:/data/riak-2.1.1# curl -XPOST -H\"content-type: application/json\"\\\n        http://localhost:10018/mapred --data @-<<\\EOF\n    \t{\"inputs\":\"user_read_log4\",\"query\":[{\"map\":{\"language\":\"javascript\",\"source\":\"\n    \tfunction(v) {\n    \tvar data=Riak.mapValuesJson(v)[0];\n    \tvar r={};\n    \tr[data.user_id]=1;\n   \treturn [r];\n    \t}\",\"keep\":false}},\n    \t{\"reduce\":{\"language\":\"javascript\",\"source\":\"\n    \tfunction(v){\n                    var i, j, r = {}, w;\n                for (i = 0; i < v.length; i += 1) {\n                    for (w in v[i]) {\n                        if (v[i].hasOwnProperty(w)) {\n                            if (r[w]) { r[w] += v[i][w]; }\n                            else { r[w] = v[i][w]; }\n                        }\n                    }\n                }\n                return [r];\n    \t}\"\n    \t}}],\"timeout\":1000000}\n \tEOF\n\troot@localhost:/data/riak-2.1.1# date +%s\n\t1442538003\n```\n\n\n%通过http接口，使用javascript 进行Mapreduce 处理240080 条数据，1442538003-1442537754=249s\n\n```erlang\n\tmap_javascript()->\n    \t{A,B,C}=erlang:now(),\n    \t{ok, Soc1} = riakc_pb_socket:start_link(\"127.0.0.1\", 10017),\n    \tMap= <<\"function(v) { var data=Riak.mapValuesJson(v)[0];var r={};r[data.user_id]=1;return [r];}\">>,\n    \tReduce= <<\"function(v){var i, j, r = {}, w;for (i = 0; i < v.length; i += 1) {for (w in v[i]) \\\n           {if (v[i].hasOwnProperty(w)) {if (r[w]) { r[w] += v[i][w]; }else { r[w] = v[i][w]; }}}}return [r];}\" >>,\n    \tResult=riakc_pb_socket:mapred_bucket(Soc1, <<\"user_read_log4\">>, [{map, {jsanon, Map}, none, false}, {reduce, {jsanon, Reduce}, none, true}], 6000000),\n    \t{A1,B1,C1}=erlang:now(),\n    \t{Result,(A1* 1000000000000 + B1*1000000 + C1)  - (A* 1000000000000 + B*1000000+ C)}.\n\n\t(book_club_server@localhost)11> bus_user_read_behaviortrace_handler:map_javascript().\n\t{{ok,[{1,\n       \t[{struct,[{<<\"201507301601028734\">>,27301},\n                 {<<\"201507301601028728\">>,26948},\n                 {<<\"201507301601028735\">>,23250},\n                 {<<\"201507301601028733\">>,27156},\n                 {<<\"201507301601028730\">>,27175},\n                 {<<\"201507301601028732\">>,26993},\n                 {<<\"201507301601028727\">>,26930},\n                 {<<\"201507301601028729\">>,27177},\n                 {<<\"201507301601028731\">>,27150}]}]}]},240914091}\n```\n%通过PCB协议接口，使用Javascript 进行MapReduce处理240080 条数据，耗时 240914091微妙 ，约240秒.\n```\n\n\n通过上面的测试，我们就可以知道为什么Riak自己都不推荐使用Javascript 进行MapReduce了，使用Erlang  的进行MapReduce的效率几乎是 javascript 的4倍。\n\n\n\n","slug":"Riak安装与MapReduce测试","published":1,"updated":"2015-10-22T12:34:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigt9g329000fyns6xrxuhgk0"},{"title":"MQTT_V1.3_协议详解","date":"2015-10-24T06:34:53.000Z","_content":"MQTT 协议详解\n====\n\n预览\n====\n    %%        7   6   5   4      3     2   1      0\n    byte1     message_type   dupflag   QoSLV   RETAIN\n    byte2     Remaining Length\n    byte3      Variable header\n    byten       ....\n                    MSG\n\nFixed header（固定头部）\n====\n    %%        7   6   5   4      3     2   1      0\n    byte1     message_type   dupflag   QoSLV   RETAIN\n    byte2     Remaining Length\n\n* message_type:消息类型，第4-7位比特，不同的值表示不同的意思，具体如下：\n    1. 1 ：CONNECT,客户端请求连接服务器\t       \n    2. 2 : CONNACK,连接应答\n    3. 3 ：PUBLISH ,发布一条消息      \t\n    4. 4 :  PUBACK, 发布应答        \t\n    5. 5 :  PUBREC, 发布被接收应答发布1        \t\n    6. 6 ：PUBREL ，发布释放应答发布2        \t\n    7. 7 : PUBCOMP,发布完成应答发布3        \t\n    8. 8 ：SUBSCRIBE,请求订阅        \t\n    9. 9 ：SUBACK,订阅应答        \t\n    10. 10 ：UNSUBSCRIBE ,取消订阅\n    11. 11 ：unsuback,取消订阅应答\n    12. 12 ：PINGREQ ,ping请求\n    13. 13 ：PINGRESP,ping回应\n    14. 14 ：DISCONNECT,客户端断开连接\n    15. 15 ：保留\n\n* DUP:用于标识是否是重发的发布，发布应答，订阅，取消订阅的消息，当QoS大于0，且设置必须应答时。\n* QoS:消息的发送保证级别；0：至多一次，1：至少1次 ；2：只有一次 3：保留\n* RETAIN：对发布消息有用，为1时标识发布的消息对新订阅的用户有用，且需要持久化，\n* Remaining Length:低7位为消息的字节数量，第8位为下一个字节也是长度标志位，最大为四个字节。\n\n\nVariable Header(可变头部)\n====\n某些MQTT的命令会包含一个可变的头部组件，它位于 固定头部（fixed header)和负载之间。\nProtocol name(协议名称）\n====\n协议名出现在一条MQTT 连接消息的可变头部中，这个字段是UTF编码，比如 MQIsdp 或MQTT\n\nProtocol version（协议版本）\n====\n协议版本字段出先在一条MQTT连接消息的可变头部中，占用一个字节。\n\nConnect flag（连接标识）\n====\nClean_session,WILL,Will QoS,Retain flags 出现在CONNECT 消息的可变头部。\n\nClean session flag\n====\n位置：在connect flag字节的 第1位（从0位开始），如果该位不置1则服务器需要持久化该客户端的订阅消息，以便下一次连接后继续使用。如果置1，则客户端断开后清空订阅信息，每次连接都需要重新订阅信息。\n\nWill QoS、Will flag 、Will Message\n====\n位置：在connect flag 字节的第3 和第4位\n這三個flag，就是在MQTT簡介裡被提到的 最後遺囑(Last Will and Testament) 機制所用的flag。這機制是這樣的，client在一開始發送CONNECT訊息給server要求建立連線時，就把要對哪個主題說什麼遺言一起傳給server，當它在不正常的情況下斷線時(比如說網路連線斷掉、裝置故障等等)，則這些訊息就會被server主動發佈到該主題上。如果是client主動發送DISCONNECT訊息給server要求斷線時，則此機制將不會有作用。\n\n要啟動此機制，首先就是要將Will flag設為1，這樣就代表要啟用，之後你設定遺言的QoS level為何，server會依照你設定的QoS level來幫你傳送訊息，最後設定此此則遺言是否要保留(Retain)在server上。如果有設定Will flag，則在pyaload內會需要定義Will Topic和Will Message，也就是要對哪個主題發送什麼樣的遺言。\n\nUser name 和 password 标识\n====\n位置：在connect flag 字节的第6和第7位\n客户端在连接时指明是否包含了登陆名称和登陆密码。\n\nKeep Alive timer（存活定时器）\n====\nkeep alive timer 出现在一个CONNECT消息的可变头部，定义了从客户端接受消息的最大间隔时间（秒），可用于服务端心跳包机制来判断与客户端的网络连接是否已经断开。keep alive timer 字段大小为两个字节，0表示客户端用于不会断开。\n\nConnect return code 返回码\n====\nconnect return code出现 在CONNACK 消息中，大小为一个字节，当前有意义的值是：\n- 0x00 : 接受连接\n- 0x01:  拒绝连接，协议版本不可用\n- 0x02:  连接失败，标识拒绝\n- 0x03:  服务器连接失败\n- 0x04:  用户名和密码错误\n- 0x05:  没有验证\n\nTopic name (订阅名称）\n====\ntopic name 出现在MQTT PUBLISH 消息的可变头部，用来标明发布消息所属的channel，订阅时使用该值来标明从哪里接收发布消息。\n\n","source":"_posts/MQTT-V1-3-协议详解.md","raw":"title: MQTT_V1.3_协议详解\ndate: 2015-10-24 14:34:53\ntags: [mqtt]\n---\nMQTT 协议详解\n====\n\n预览\n====\n    %%        7   6   5   4      3     2   1      0\n    byte1     message_type   dupflag   QoSLV   RETAIN\n    byte2     Remaining Length\n    byte3      Variable header\n    byten       ....\n                    MSG\n\nFixed header（固定头部）\n====\n    %%        7   6   5   4      3     2   1      0\n    byte1     message_type   dupflag   QoSLV   RETAIN\n    byte2     Remaining Length\n\n* message_type:消息类型，第4-7位比特，不同的值表示不同的意思，具体如下：\n    1. 1 ：CONNECT,客户端请求连接服务器\t       \n    2. 2 : CONNACK,连接应答\n    3. 3 ：PUBLISH ,发布一条消息      \t\n    4. 4 :  PUBACK, 发布应答        \t\n    5. 5 :  PUBREC, 发布被接收应答发布1        \t\n    6. 6 ：PUBREL ，发布释放应答发布2        \t\n    7. 7 : PUBCOMP,发布完成应答发布3        \t\n    8. 8 ：SUBSCRIBE,请求订阅        \t\n    9. 9 ：SUBACK,订阅应答        \t\n    10. 10 ：UNSUBSCRIBE ,取消订阅\n    11. 11 ：unsuback,取消订阅应答\n    12. 12 ：PINGREQ ,ping请求\n    13. 13 ：PINGRESP,ping回应\n    14. 14 ：DISCONNECT,客户端断开连接\n    15. 15 ：保留\n\n* DUP:用于标识是否是重发的发布，发布应答，订阅，取消订阅的消息，当QoS大于0，且设置必须应答时。\n* QoS:消息的发送保证级别；0：至多一次，1：至少1次 ；2：只有一次 3：保留\n* RETAIN：对发布消息有用，为1时标识发布的消息对新订阅的用户有用，且需要持久化，\n* Remaining Length:低7位为消息的字节数量，第8位为下一个字节也是长度标志位，最大为四个字节。\n\n\nVariable Header(可变头部)\n====\n某些MQTT的命令会包含一个可变的头部组件，它位于 固定头部（fixed header)和负载之间。\nProtocol name(协议名称）\n====\n协议名出现在一条MQTT 连接消息的可变头部中，这个字段是UTF编码，比如 MQIsdp 或MQTT\n\nProtocol version（协议版本）\n====\n协议版本字段出先在一条MQTT连接消息的可变头部中，占用一个字节。\n\nConnect flag（连接标识）\n====\nClean_session,WILL,Will QoS,Retain flags 出现在CONNECT 消息的可变头部。\n\nClean session flag\n====\n位置：在connect flag字节的 第1位（从0位开始），如果该位不置1则服务器需要持久化该客户端的订阅消息，以便下一次连接后继续使用。如果置1，则客户端断开后清空订阅信息，每次连接都需要重新订阅信息。\n\nWill QoS、Will flag 、Will Message\n====\n位置：在connect flag 字节的第3 和第4位\n這三個flag，就是在MQTT簡介裡被提到的 最後遺囑(Last Will and Testament) 機制所用的flag。這機制是這樣的，client在一開始發送CONNECT訊息給server要求建立連線時，就把要對哪個主題說什麼遺言一起傳給server，當它在不正常的情況下斷線時(比如說網路連線斷掉、裝置故障等等)，則這些訊息就會被server主動發佈到該主題上。如果是client主動發送DISCONNECT訊息給server要求斷線時，則此機制將不會有作用。\n\n要啟動此機制，首先就是要將Will flag設為1，這樣就代表要啟用，之後你設定遺言的QoS level為何，server會依照你設定的QoS level來幫你傳送訊息，最後設定此此則遺言是否要保留(Retain)在server上。如果有設定Will flag，則在pyaload內會需要定義Will Topic和Will Message，也就是要對哪個主題發送什麼樣的遺言。\n\nUser name 和 password 标识\n====\n位置：在connect flag 字节的第6和第7位\n客户端在连接时指明是否包含了登陆名称和登陆密码。\n\nKeep Alive timer（存活定时器）\n====\nkeep alive timer 出现在一个CONNECT消息的可变头部，定义了从客户端接受消息的最大间隔时间（秒），可用于服务端心跳包机制来判断与客户端的网络连接是否已经断开。keep alive timer 字段大小为两个字节，0表示客户端用于不会断开。\n\nConnect return code 返回码\n====\nconnect return code出现 在CONNACK 消息中，大小为一个字节，当前有意义的值是：\n- 0x00 : 接受连接\n- 0x01:  拒绝连接，协议版本不可用\n- 0x02:  连接失败，标识拒绝\n- 0x03:  服务器连接失败\n- 0x04:  用户名和密码错误\n- 0x05:  没有验证\n\nTopic name (订阅名称）\n====\ntopic name 出现在MQTT PUBLISH 消息的可变头部，用来标明发布消息所属的channel，订阅时使用该值来标明从哪里接收发布消息。\n\n","slug":"MQTT-V1-3-协议详解","published":1,"updated":"2015-10-24T06:35:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigt9g32b000kyns6ta0hbmj7"},{"title":"Erlang通过NIF集成c代码示例","date":"2015-10-22T13:24:21.000Z","_content":"\nERLANG NIF 编写\n===\n\n很多时候一下计算量大，效率要求很高的地方也许使用c会好于erlang。\n\nErlang层代码\n====\n-  通过 `-on_load`模块属性，实现erlang vm 加载模块时同时加载c的共享库文件。\n-   nif的函数erlang入口为 func(args) -> erlang:nif_error({error,not_loaded}).\n\nC层代码\n====\n- 包含 erl_nif.h  , `#include<erl_nif.h>`，\n- 注册NIF ,这里分为了三步：\n  1. ErlNifFunc 数组，告诉erlang vm 库中实现的NIF，以及erlang函数名对应的c实现函数:\n\tstatic ErlNifFunc test_nifs[] =\n\t{ \n \t{\"hello\",1,&hello_1} \n\t};\n  2. ERL_NIF_INIT宏 将 ErlNifFunc数组联同所属模块的模块名告诉Erlang vm。`ERL_NIF_INIT(test_nif,test_nifs,NULL,NULL,NULL,NULL);`\n  3. c实现函数 `static ERL_NIF_TERM hello_1(ErlNifEnv * env,int argc,const ERL_NIF_TERM argv[])` , 函数接受3个参数，并返回一个ERL_NIF_TERM对象，第一个参数env就是前面提到过的ErlNifEnv 指针。第二个参数argc是Erlang调用NIF时传入的参数数目。第三个参数argv中的元素就是传入的各个参数（数目与argc中的一致）。\n\n3.编译c代码\n   `gcc -o test_nif.so -fpic -shared -I/usr/local/lib/erlang/erts-5.10.4/include test_nif.c`.\n\ntest_nif.c\n\n```c\n#include<erl_nif.h>\n#include<string.h>\nstatic ERL_NIF_TERM hello_1(ErlNifEnv * env,int argc,const ERL_NIF_TERM argv[])\n{\n \treturn enif_make_tuple2(env,enif_make_atom(env,\"hello\"),argv[0]);\n}\nstatic ErlNifFunc test_nifs[] =\n{ \n \t{\"hello\",1,&hello_1} \n};\nERL_NIF_INIT(test_nif,test_nifs,NULL,NULL,NULL,NULL);\n```\n\ntest_nif.erl\n\n```erlang\n-module(test_nif).\n-on_load(init/0).\n-export([hello/1]).\ninit()->\n \terlang:load_nif(\"./test_nif\",0);\nhello(Arg)->\n \terlang:nif_error({error, not_loaded}).\n ```\n\n","source":"_posts/Erlang通过NIF集成c代码示例.md","raw":"title: Erlang通过NIF集成c代码示例\ndate: 2015-10-22 21:24:21\ntags: [Erlang]\n---\n\nERLANG NIF 编写\n===\n\n很多时候一下计算量大，效率要求很高的地方也许使用c会好于erlang。\n\nErlang层代码\n====\n-  通过 `-on_load`模块属性，实现erlang vm 加载模块时同时加载c的共享库文件。\n-   nif的函数erlang入口为 func(args) -> erlang:nif_error({error,not_loaded}).\n\nC层代码\n====\n- 包含 erl_nif.h  , `#include<erl_nif.h>`，\n- 注册NIF ,这里分为了三步：\n  1. ErlNifFunc 数组，告诉erlang vm 库中实现的NIF，以及erlang函数名对应的c实现函数:\n\tstatic ErlNifFunc test_nifs[] =\n\t{ \n \t{\"hello\",1,&hello_1} \n\t};\n  2. ERL_NIF_INIT宏 将 ErlNifFunc数组联同所属模块的模块名告诉Erlang vm。`ERL_NIF_INIT(test_nif,test_nifs,NULL,NULL,NULL,NULL);`\n  3. c实现函数 `static ERL_NIF_TERM hello_1(ErlNifEnv * env,int argc,const ERL_NIF_TERM argv[])` , 函数接受3个参数，并返回一个ERL_NIF_TERM对象，第一个参数env就是前面提到过的ErlNifEnv 指针。第二个参数argc是Erlang调用NIF时传入的参数数目。第三个参数argv中的元素就是传入的各个参数（数目与argc中的一致）。\n\n3.编译c代码\n   `gcc -o test_nif.so -fpic -shared -I/usr/local/lib/erlang/erts-5.10.4/include test_nif.c`.\n\ntest_nif.c\n\n```c\n#include<erl_nif.h>\n#include<string.h>\nstatic ERL_NIF_TERM hello_1(ErlNifEnv * env,int argc,const ERL_NIF_TERM argv[])\n{\n \treturn enif_make_tuple2(env,enif_make_atom(env,\"hello\"),argv[0]);\n}\nstatic ErlNifFunc test_nifs[] =\n{ \n \t{\"hello\",1,&hello_1} \n};\nERL_NIF_INIT(test_nif,test_nifs,NULL,NULL,NULL,NULL);\n```\n\ntest_nif.erl\n\n```erlang\n-module(test_nif).\n-on_load(init/0).\n-export([hello/1]).\ninit()->\n \terlang:load_nif(\"./test_nif\",0);\nhello(Arg)->\n \terlang:nif_error({error, not_loaded}).\n ```\n\n","slug":"Erlang通过NIF集成c代码示例","published":1,"updated":"2015-10-22T13:24:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigt9g32d000nyns6os1ksak9"},{"title":"Erlang发送邮件相关问题","date":"2015-10-22T10:22:11.000Z","_content":"Erlang 发送邮件相关问题\n====\n\n1. 协议相关\n=====\n一封邮件的发送的协议格式如下：\n\n\t\"HELO XXX\\r\\n\"\n\t\"AUTH LOGIN \\r\\r\"\n\t\"$Account\\r\\n\" ($Account为账号需要经过base64 encoding）\n\t\"$Password\\r\\n\" ($Password 为密码需要经过base64 encoding)\n\t\"DATA\\r\\n\"\n\t\"From: < $Account> \\r\\n\" ($Account 为发送者的email\n\t\"To : < $ToEmails >\\r\\n\" ($ToEmails 为发送者的列表）\n\t\"Subject: =?UTF-8?B? $Tittle ?=\\r\\n\"($Tittle 是邮件标题经过base64 编码后的字符串，这样做的目的是为了避免中文乱码）\n\t\"MIME-version: 1.0\\r\\n\"\n\t\"Content-Type:text/html;charset=UTF-8\\r\\n\\r\\n\"\n\t\"$DATA\\r\\n\\r\\n\" (正文内容）\n\t\"\\r\\n.\\r\\n\"(结束）\n\t\"QUIT\\r\\n\"(退出）\n\n2.乱码问题\n=====\nErlang 处理中文，唯一办法就是转换成utf-8 ,所以在smtp协议里面就需要指明对应的编码，所以标题需要改为`\"Subject: =?UTF-8?B? $Tittle ?=\\r\\n\"($Tittle 是邮件标题经过base64编码后的字符串，这样做的目的是为了避免中文乱码)` , 正文部分需要指明charset ：`\"Content-Type:text/html;charset=UTF-8\\r\\n\\r\\n\"`\n\n3. 相关资料\n======\n- http://wdicc.com/sendmail-use-perl/\n- http://www.cnblogs.com/quitboy/p/4605694.html\n- http://www.chinaemail.com.cn/blog/content/667/\n","source":"_posts/Erlang发送邮件相关问题.md","raw":"title: Erlang发送邮件相关问题\ndate: 2015-10-22 18:22:11\ntags: [Erlang]\n---\nErlang 发送邮件相关问题\n====\n\n1. 协议相关\n=====\n一封邮件的发送的协议格式如下：\n\n\t\"HELO XXX\\r\\n\"\n\t\"AUTH LOGIN \\r\\r\"\n\t\"$Account\\r\\n\" ($Account为账号需要经过base64 encoding）\n\t\"$Password\\r\\n\" ($Password 为密码需要经过base64 encoding)\n\t\"DATA\\r\\n\"\n\t\"From: < $Account> \\r\\n\" ($Account 为发送者的email\n\t\"To : < $ToEmails >\\r\\n\" ($ToEmails 为发送者的列表）\n\t\"Subject: =?UTF-8?B? $Tittle ?=\\r\\n\"($Tittle 是邮件标题经过base64 编码后的字符串，这样做的目的是为了避免中文乱码）\n\t\"MIME-version: 1.0\\r\\n\"\n\t\"Content-Type:text/html;charset=UTF-8\\r\\n\\r\\n\"\n\t\"$DATA\\r\\n\\r\\n\" (正文内容）\n\t\"\\r\\n.\\r\\n\"(结束）\n\t\"QUIT\\r\\n\"(退出）\n\n2.乱码问题\n=====\nErlang 处理中文，唯一办法就是转换成utf-8 ,所以在smtp协议里面就需要指明对应的编码，所以标题需要改为`\"Subject: =?UTF-8?B? $Tittle ?=\\r\\n\"($Tittle 是邮件标题经过base64编码后的字符串，这样做的目的是为了避免中文乱码)` , 正文部分需要指明charset ：`\"Content-Type:text/html;charset=UTF-8\\r\\n\\r\\n\"`\n\n3. 相关资料\n======\n- http://wdicc.com/sendmail-use-perl/\n- http://www.cnblogs.com/quitboy/p/4605694.html\n- http://www.chinaemail.com.cn/blog/content/667/\n","slug":"Erlang发送邮件相关问题","published":1,"updated":"2015-10-22T10:23:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigt9g32e000pyns6o0vy48sh"},{"title":"Erlang_Efficiency_guide_非标准笔记","date":"2015-10-24T06:27:28.000Z","_content":"Efficiency guide 译文\n===\n\ntimer模块\n====\n通过`erlang:send_after/3` 或`erlang:start_timer/3` 来启动一个定时器会比使用timer模块更加有效率。timer模块使用一个独立的进程来管理定时器，因此该进程很容易过载，如果很多进程频繁创建或取消定时器。\n\n`list_to_atom/1`\n====\nAtoms 是不参与垃圾回收的。一旦一个原子被创建，它将不会被回收，Erlang虚拟机会因为atoms数量太多（默认1048576）而导致崩溃。\n因此，转换输入的字符参数变成atom会导致系统变得不安全。如果只允许已经定义的原子可以允许被转换，可以使用 `list_to_existing_atom/1`去避免服务器崩溃。（这就使得我们需要提前创建所有允许被创建的atiom\n\n`length/1`\n====\n执行`length/1`所消耗的时间是与输入列表的长度成比例增长的。而 `erlang:tuple_size/1`、`byte_size/1`、和`bit_size/1`的执行时间是常量时间。因此避免对长度过长的list进行`leng/1`运算。一些对`length/1`的使用可以被替换成模式匹配，比如：\n    foo(L) when length(L) >=3 -> .....\n可以替换为\n    foo([_,_,_|_]=L)->....\n另外对不使用的变量命名为`_`也可以提升程序效率。\n\n`setelement/3`\n====\n`setelement/3`复制它修改的元祖，因此，在循环中调用`setelement/3`将会每次都创建新的副本。如果无法优化循环调用`setelement/3`的代码，那么对一个大tuple修改多个元素的最优办法就是将tuple转换为list修改list后再转换会tuple。\n\n`size/1`\n====\n`size/1`可以返回tuple或binary的大小。使用 BIFs `tuple_size/1`和 `byte_size/1`可以让编译器和运行时系统去优化性能。\n\n`split_binary/2`\n====\n通过模式匹配来切分binary会比调用`split_binary/2`来的快。另外，混合比特语法匹配和split_binary/2 会阻止一些对对比特语法匹配的优化。\n这样：\n    \"  Bin1:Num/binary,Bin2/binary  \" =Bin`\n而不要：\n    {Bin1,Bin2}=split_binary(Bin,Num)\n\n'--'操作符\n====\n列表的长度越长，`--`的效率就越低。\n不要：\n    HugeList1 -- HugeList2\n而是这样(对列表元素没有顺序要求的列表使用）：\n    HugeSet1 = ordsets:from_list(HugeList1),\n    HugeSet2 = ordsets:from_list(HugeList2),\n    ordsets:subtract(HugeSet1,HugeSet2)\n对于对列表元素有顺序要求的列表：\n`    Set=gb_sets:from_list(HugeList2),\n    [E|| E 《-HugeList1, not gb_sets:is_element(E，Set)]`\n\nbinaries 是如何被实例化的\n====\n在内部来说，binaries和bitstring是一样的东西。\n在虚拟机内部有四种类型的binary对象。有两种包含了binary数据，另外两种仅仅只是引用了binary的一部分。而binary容器是 引用binaries（引用计数binaries的缩写）和堆binaries（heap binaries）。\n- Refc binaries 包含两部分：\n  1.一个保存在进程堆的（process heap）对象，即ProcBin,所有的ProcBin都是进程链接的一部分，因此gc 会追踪它们，并且在ProcBin消失后减少引用次数。\n  2.保存在所有进程堆之外的binary对象，binary对象可以被任意个ProcBins（任意个进程中）引用，它包含了引用计数器用来计算当前引用的数量，当引用数量为0时就会被回收。\n- Heap binaries 是小binaries，最大为64字节。所以直接保存在程序的堆中。它将会在进程gc或当作消息发送时被复制，gc不需要任何的处理就可以回收。\n有两种类型的引用对象可以引用 一个refc binary 或 heap binary，它们就是 sub binaries 和 匹配文本。\nsub binaries 由 `split_binary/2` 创建或者匹配到一个binary时。sun binaries 只是引用了其他binaries的一部分（refc binaries 或heap binary），因此匹配binaries是非常廉价的，因为他不会发生任何的拷贝。\n上下文匹配和sub binary类似，不同的是对binary 匹配做了优化；举个例子，它包含了一个直接指向binary数据的指针。\n\n构造二进制\n====\n运行时系统特别对附加binary作了优化，举个例子：\n    Bin0= \"  0 \",  %%为变量Bin0绑定一个heap binary，\n    Bin1=\"  Bin0/binary,1,2,3  \"  %%创建一个refc binary 其内容是Bin0的副本，refc binary的ProcBin部分拥有数据的大小（数据存储到二进制中的大小），binary object 却会有额外的空间被开辟，binary object的大小可能是 Bin0的两倍或者是256（或者更大）。\n    Bin2 =\" Bin1/binary,4,5,6\"\n\n\n\n","source":"_posts/Erlang-Efficiency-guide-非标准笔记.md","raw":"title: Erlang_Efficiency_guide_非标准笔记\ndate: 2015-10-24 14:27:28\ntags: [Erlang]\n---\nEfficiency guide 译文\n===\n\ntimer模块\n====\n通过`erlang:send_after/3` 或`erlang:start_timer/3` 来启动一个定时器会比使用timer模块更加有效率。timer模块使用一个独立的进程来管理定时器，因此该进程很容易过载，如果很多进程频繁创建或取消定时器。\n\n`list_to_atom/1`\n====\nAtoms 是不参与垃圾回收的。一旦一个原子被创建，它将不会被回收，Erlang虚拟机会因为atoms数量太多（默认1048576）而导致崩溃。\n因此，转换输入的字符参数变成atom会导致系统变得不安全。如果只允许已经定义的原子可以允许被转换，可以使用 `list_to_existing_atom/1`去避免服务器崩溃。（这就使得我们需要提前创建所有允许被创建的atiom\n\n`length/1`\n====\n执行`length/1`所消耗的时间是与输入列表的长度成比例增长的。而 `erlang:tuple_size/1`、`byte_size/1`、和`bit_size/1`的执行时间是常量时间。因此避免对长度过长的list进行`leng/1`运算。一些对`length/1`的使用可以被替换成模式匹配，比如：\n    foo(L) when length(L) >=3 -> .....\n可以替换为\n    foo([_,_,_|_]=L)->....\n另外对不使用的变量命名为`_`也可以提升程序效率。\n\n`setelement/3`\n====\n`setelement/3`复制它修改的元祖，因此，在循环中调用`setelement/3`将会每次都创建新的副本。如果无法优化循环调用`setelement/3`的代码，那么对一个大tuple修改多个元素的最优办法就是将tuple转换为list修改list后再转换会tuple。\n\n`size/1`\n====\n`size/1`可以返回tuple或binary的大小。使用 BIFs `tuple_size/1`和 `byte_size/1`可以让编译器和运行时系统去优化性能。\n\n`split_binary/2`\n====\n通过模式匹配来切分binary会比调用`split_binary/2`来的快。另外，混合比特语法匹配和split_binary/2 会阻止一些对对比特语法匹配的优化。\n这样：\n    \"  Bin1:Num/binary,Bin2/binary  \" =Bin`\n而不要：\n    {Bin1,Bin2}=split_binary(Bin,Num)\n\n'--'操作符\n====\n列表的长度越长，`--`的效率就越低。\n不要：\n    HugeList1 -- HugeList2\n而是这样(对列表元素没有顺序要求的列表使用）：\n    HugeSet1 = ordsets:from_list(HugeList1),\n    HugeSet2 = ordsets:from_list(HugeList2),\n    ordsets:subtract(HugeSet1,HugeSet2)\n对于对列表元素有顺序要求的列表：\n`    Set=gb_sets:from_list(HugeList2),\n    [E|| E 《-HugeList1, not gb_sets:is_element(E，Set)]`\n\nbinaries 是如何被实例化的\n====\n在内部来说，binaries和bitstring是一样的东西。\n在虚拟机内部有四种类型的binary对象。有两种包含了binary数据，另外两种仅仅只是引用了binary的一部分。而binary容器是 引用binaries（引用计数binaries的缩写）和堆binaries（heap binaries）。\n- Refc binaries 包含两部分：\n  1.一个保存在进程堆的（process heap）对象，即ProcBin,所有的ProcBin都是进程链接的一部分，因此gc 会追踪它们，并且在ProcBin消失后减少引用次数。\n  2.保存在所有进程堆之外的binary对象，binary对象可以被任意个ProcBins（任意个进程中）引用，它包含了引用计数器用来计算当前引用的数量，当引用数量为0时就会被回收。\n- Heap binaries 是小binaries，最大为64字节。所以直接保存在程序的堆中。它将会在进程gc或当作消息发送时被复制，gc不需要任何的处理就可以回收。\n有两种类型的引用对象可以引用 一个refc binary 或 heap binary，它们就是 sub binaries 和 匹配文本。\nsub binaries 由 `split_binary/2` 创建或者匹配到一个binary时。sun binaries 只是引用了其他binaries的一部分（refc binaries 或heap binary），因此匹配binaries是非常廉价的，因为他不会发生任何的拷贝。\n上下文匹配和sub binary类似，不同的是对binary 匹配做了优化；举个例子，它包含了一个直接指向binary数据的指针。\n\n构造二进制\n====\n运行时系统特别对附加binary作了优化，举个例子：\n    Bin0= \"  0 \",  %%为变量Bin0绑定一个heap binary，\n    Bin1=\"  Bin0/binary,1,2,3  \"  %%创建一个refc binary 其内容是Bin0的副本，refc binary的ProcBin部分拥有数据的大小（数据存储到二进制中的大小），binary object 却会有额外的空间被开辟，binary object的大小可能是 Bin0的两倍或者是256（或者更大）。\n    Bin2 =\" Bin1/binary,4,5,6\"\n\n\n\n","slug":"Erlang-Efficiency-guide-非标准笔记","published":1,"updated":"2015-10-26T17:49:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigt9g32h000ryns6kv8jd1fn"},{"title":"Cowboy的路由机制","date":"2015-10-22T10:24:56.000Z","_content":"\n路由机制\n=====\n配置链接URL到Erlang模块（处理对应请求的模块）的映射就是路由。\n\n当 Cowboy接收到一个请求时，它会尝试在给定的分发规则中匹配 域名 到对应的资源路径。如果匹配成功，那么对应的Erlang 模块就会被执行。\n\nCowboy首先会匹配域名，接着尝试找到匹配的资源路径。\n\nCowboy会将路由规则编译后，再使用。\n\n\n结构\n=====\n通用的路由结构是这样定义的：\n`Routes= [Host1, Host2, ... HostN].`\n\n每一个域名的匹配规则 包含了 对连接路径的选项约束和路径部件的列表。\n\n`Host1= {HostMatch, PathsList}.`\n`Host2= {HostMatch, Constraints, PathsList}.`\n\n路径部件的定义如下：\n`PathsList= [Path1, Path2, ... PathN].`\n\n最后，每一路径包含了该路径自身的匹配规则以及对应的处理模块\n`Path1= {PathMatch, Handler, Opts}.`\n`Path2= {PathMatch, Constraints, Handler, Opts}.`\n\n匹配规则语法\n=====\n匹配语法规则用于标识 域名到路径间的处理handlers。\n域名的语法规则：\n`HostMatch1= \"cowboy.example.org\".`\n`HostMatch2= \"cowboy.example.org.\".`\n`HostMatch3= \".cowboy.example.org\".`\n\n路径的语法规则：\n`PathMatch= \"/hats/:name/prices\".`\n`HostMatch= \":subdomain.example.org\".`\n\n此外，还可以将域名的某一字段保存到Req对象中，再后续可以使用，这就是值绑定。\n`PathMatch= \"/hats/:name/prices\".`\n`HostMatch= \":subdomain.example.org\".`\n比如，http://test.example.org/hats/wild_cowboy_legendary/prices 将会\n把test绑定到subdomain，而wild_cowboy_legendary就会绑定到name，它们可以被cow_req:binding/{2,3}中检索，绑定的名字必须是一个atom\n'_'：表示匹配任何内容\n\n约束\n=====\n匹配域名和路径完成后，就会检测是否满足可选的约束，约束如下：\n```erlang\n{Name, int}\n{Name, function, fun ((Value) -> true | {true, NewValue} | false)}\n```\nint 约束将会检查 绑定的二进制串是一个int，或可被转化成一个int\nfunction约束，将会调用给定的约束函数并且返回结果，给定函数必须自己保证不会崩溃的。\n\n\n为了保存Cowboy可以更高效地查找正确的handler模块，Cowboy会编译定义好的路由分发规则。\n编译的方法是：cowboy_router:compile/1.\n```erlang\n\tDispatch= cowboy_router:compile([\n    %% {HostMatch, list({PathMatch, Handler, Opts})}\n    {'_', [{'_', my_handler, []}]}\n\t]),\n\t%% Name, NbAcceptors, TransOpts, ProtoOpts\n\tcowboy:start_http(my_http_listener, 100,\n   \t[{port, 8080}],\n   \t[{env, [{dispatch, Dispatch}]}]\n\t).\n```\n如果定义好的路由分发规则有错误，cowboy_router:compile/1 \n将会返回{error, badarg}\n\n在线更新路由规则\n=====\n通过 cowboy:set_env/3更新路由的分发规则，连接监听模块接受新的连接时就会使用新的路由分发规则。\n```erlang\n    cowboy:set_env(my_http_listener, dispatch,\n    cowboy_router:compile(Dispatch)).\n```\n\n\n\n\n","source":"_posts/Cowboy的路由机制.md","raw":"title: Cowboy的路由机制\ndate: 2015-10-22 18:24:56\ntags: [Cowboy]\n---\n\n路由机制\n=====\n配置链接URL到Erlang模块（处理对应请求的模块）的映射就是路由。\n\n当 Cowboy接收到一个请求时，它会尝试在给定的分发规则中匹配 域名 到对应的资源路径。如果匹配成功，那么对应的Erlang 模块就会被执行。\n\nCowboy首先会匹配域名，接着尝试找到匹配的资源路径。\n\nCowboy会将路由规则编译后，再使用。\n\n\n结构\n=====\n通用的路由结构是这样定义的：\n`Routes= [Host1, Host2, ... HostN].`\n\n每一个域名的匹配规则 包含了 对连接路径的选项约束和路径部件的列表。\n\n`Host1= {HostMatch, PathsList}.`\n`Host2= {HostMatch, Constraints, PathsList}.`\n\n路径部件的定义如下：\n`PathsList= [Path1, Path2, ... PathN].`\n\n最后，每一路径包含了该路径自身的匹配规则以及对应的处理模块\n`Path1= {PathMatch, Handler, Opts}.`\n`Path2= {PathMatch, Constraints, Handler, Opts}.`\n\n匹配规则语法\n=====\n匹配语法规则用于标识 域名到路径间的处理handlers。\n域名的语法规则：\n`HostMatch1= \"cowboy.example.org\".`\n`HostMatch2= \"cowboy.example.org.\".`\n`HostMatch3= \".cowboy.example.org\".`\n\n路径的语法规则：\n`PathMatch= \"/hats/:name/prices\".`\n`HostMatch= \":subdomain.example.org\".`\n\n此外，还可以将域名的某一字段保存到Req对象中，再后续可以使用，这就是值绑定。\n`PathMatch= \"/hats/:name/prices\".`\n`HostMatch= \":subdomain.example.org\".`\n比如，http://test.example.org/hats/wild_cowboy_legendary/prices 将会\n把test绑定到subdomain，而wild_cowboy_legendary就会绑定到name，它们可以被cow_req:binding/{2,3}中检索，绑定的名字必须是一个atom\n'_'：表示匹配任何内容\n\n约束\n=====\n匹配域名和路径完成后，就会检测是否满足可选的约束，约束如下：\n```erlang\n{Name, int}\n{Name, function, fun ((Value) -> true | {true, NewValue} | false)}\n```\nint 约束将会检查 绑定的二进制串是一个int，或可被转化成一个int\nfunction约束，将会调用给定的约束函数并且返回结果，给定函数必须自己保证不会崩溃的。\n\n\n为了保存Cowboy可以更高效地查找正确的handler模块，Cowboy会编译定义好的路由分发规则。\n编译的方法是：cowboy_router:compile/1.\n```erlang\n\tDispatch= cowboy_router:compile([\n    %% {HostMatch, list({PathMatch, Handler, Opts})}\n    {'_', [{'_', my_handler, []}]}\n\t]),\n\t%% Name, NbAcceptors, TransOpts, ProtoOpts\n\tcowboy:start_http(my_http_listener, 100,\n   \t[{port, 8080}],\n   \t[{env, [{dispatch, Dispatch}]}]\n\t).\n```\n如果定义好的路由分发规则有错误，cowboy_router:compile/1 \n将会返回{error, badarg}\n\n在线更新路由规则\n=====\n通过 cowboy:set_env/3更新路由的分发规则，连接监听模块接受新的连接时就会使用新的路由分发规则。\n```erlang\n    cowboy:set_env(my_http_listener, dispatch,\n    cowboy_router:compile(Dispatch)).\n```\n\n\n\n\n","slug":"Cowboy的路由机制","published":1,"updated":"2015-10-22T10:25:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigt9g32j000tyns6wtzi63c4"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cigt9g3200002yns6o0iou6v5","tag_id":"cigt9g3230003yns68vcuh046","_id":"cigt9g3240006yns6go7digoy"},{"post_id":"cigt9g3200002yns6o0iou6v5","tag_id":"cigt9g3240004yns6p1q75v4e","_id":"cigt9g3240007yns66e8kq06b"},{"post_id":"cigt9g3200002yns6o0iou6v5","tag_id":"cigt9g3240005yns6fgon255k","_id":"cigt9g3240008yns601aj96td"},{"post_id":"cigt9g3250009yns6zh3n9zt0","tag_id":"cigt9g326000ayns6t18omqxl","_id":"cigt9g326000byns64g6ilqkd"},{"post_id":"cigt9g327000cyns6ivxpa7yj","tag_id":"cigt9g328000dyns6xc91wyiw","_id":"cigt9g328000eyns6ns2sow0g"},{"post_id":"cigt9g329000fyns6xrxuhgk0","tag_id":"cigt9g32a000gyns6qazfgpaa","_id":"cigt9g32a000iyns6gcpy3ze1"},{"post_id":"cigt9g329000fyns6xrxuhgk0","tag_id":"cigt9g32a000hyns66ai2xvyk","_id":"cigt9g32a000jyns61idfb3tw"},{"post_id":"cigt9g32b000kyns6ta0hbmj7","tag_id":"cigt9g32b000lyns6v5itsexl","_id":"cigt9g32c000myns68iy3cuuu"},{"post_id":"cigt9g32d000nyns6os1ksak9","tag_id":"cigt9g3230003yns68vcuh046","_id":"cigt9g32d000oyns6c122l14i"},{"post_id":"cigt9g32e000pyns6o0vy48sh","tag_id":"cigt9g3230003yns68vcuh046","_id":"cigt9g32g000qyns664e5wb15"},{"post_id":"cigt9g32h000ryns6kv8jd1fn","tag_id":"cigt9g3230003yns68vcuh046","_id":"cigt9g32i000syns6xnzxmmh6"},{"post_id":"cigt9g32j000tyns6wtzi63c4","tag_id":"cigt9g32k000uyns6jt3iq581","_id":"cigt9g32k000vyns688yt45fn"}],"Tag":[{"name":"Erlang","_id":"cigt9g3230003yns68vcuh046"},{"name":"Tsung","_id":"cigt9g3240004yns6p1q75v4e"},{"name":"压测","_id":"cigt9g3240005yns6fgon255k"},{"name":"hexo","_id":"cigt9g326000ayns6t18omqxl"},{"name":"Ejabberd","_id":"cigt9g328000dyns6xc91wyiw"},{"name":"Riak","_id":"cigt9g32a000gyns6qazfgpaa"},{"name":"MapReduce","_id":"cigt9g32a000hyns66ai2xvyk"},{"name":"mqtt","_id":"cigt9g32b000lyns6v5itsexl"},{"name":"Cowboy","_id":"cigt9g32k000uyns6jt3iq581"}]}}